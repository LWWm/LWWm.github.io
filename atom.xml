<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LWWm</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-02-25T11:48:53.023Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>LWWm</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>力扣刷题笔记，回溯算法</title>
    <link href="http://example.com/2022/02/25/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%8C%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2022/02/25/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%8C%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</id>
    <published>2022-02-25T11:34:10.000Z</published>
    <updated>2022-02-25T11:48:53.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="力扣刷题笔记，回溯算法"><a href="#力扣刷题笔记，回溯算法" class="headerlink" title="力扣刷题笔记，回溯算法"></a>力扣刷题笔记，回溯算法</h1><pre><code>回溯算法是一种常用的解决问题的思想，其本质是不断“试错”，在正则表达式匹配、编译原理中的语法分析等实际的场景中都可以应用，还可以解决诸如数独、儿皇后、图的着色、全排列等数学问题。其横版程序如下：&lt;!--more--&gt;</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const visited = &#123;&#125;</span><br><span class="line">function dfs(i) &#123;</span><br><span class="line">    if (满足特定条件）&#123;</span><br><span class="line">        // 返回结果 or 退出搜索空间</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    visited[i] = true // 将当前状态标为已搜索</span><br><span class="line">    dosomething(i) // 对i做一些操作</span><br><span class="line">    for (根据i能到达的下个状态j) &#123;</span><br><span class="line">        if (!visited[j]) &#123; // 如果状态j没有被搜索过</span><br><span class="line">            dfs(j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    undo(i) // 恢复i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>下面是回溯算法知识点的部分题解：</code></pre><h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line">        ans = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(candidates, target, new ArrayList&lt;&gt;(),0);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 依次查看数组中的所有元素，每次分为两种情况：考虑和不考虑，如果不考虑即直接跳过，下标直接+1，</span><br><span class="line"> *        对于考虑的情况，因为元素可以重复使用，所以下一次的下标不变。</span><br><span class="line"> */</span><br><span class="line">    public void dfs(int[] candidates, int target, List&lt;Integer&gt; combine, int idx) &#123;</span><br><span class="line">        if (idx ==candidates.length) &#123;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        if (target == 0) &#123;</span><br><span class="line">            ans.add(new ArrayList&lt;Integer&gt;(combine));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 考虑当前元素</span><br><span class="line">        if (target - candidates[idx] &gt;= 0) &#123;</span><br><span class="line">            combine.add(candidates[idx]);</span><br><span class="line">            dfs(candidates, target - candidates[idx],combine, idx);</span><br><span class="line">            combine.remove(combine.size() - 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 跳过当前元素</span><br><span class="line">        dfs(candidates, target, combine, idx + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="47-全排列2"><a href="#47-全排列2" class="headerlink" title="47. 全排列2"></a>47. 全排列2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !vis[i - 1]) &#123;</span><br><span class="line">    continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个条件可以保证在已经排序的含有重复元素的中，每次填入的数字一定是这个数组中“从左到右第一个未被填入的数字”。假设我们有 33 个重复数排完序后相邻，那么我们一定保证每次都是拿从左往右第一个未被填过的数字，即整个数组的状态其实是保证了 [未填入，未填入，未填入] 到 [填入，未填入，未填入]，再到 [填入，填入，未填入]，最后到 [填入，填入，填入] 的过程的，因此可以达到去重的目标。</p><h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a>131. 分割回文串</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; ans;</span><br><span class="line">    List&lt;String&gt; list;</span><br><span class="line">    int n;</span><br><span class="line">    boolean[][] f;</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        n = s.length();</span><br><span class="line">        ans = new ArrayList&lt;&gt;();</span><br><span class="line">        list = new ArrayList&lt;&gt;();</span><br><span class="line">        f = new boolean[n][n];</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            Arrays.fill(f[i],true);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = n - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; n; j++) &#123;</span><br><span class="line">                f[i][j] = (s.charAt(i) == s.charAt(j)) &amp;&amp; f[i + 1][j - 1];</span><br><span class="line">                // System.out.println(i + &quot;&gt;&quot; + j +&quot;&gt;&quot;+ (s.charAt(i) == s.charAt(j)) + &quot;&gt;&quot;+ f[i + 1][j - 1] + &quot;&gt;&quot; + f[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        //     for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">        //         System.out.print(f[i][j] + &quot;   &quot;);</span><br><span class="line">        //     &#125;</span><br><span class="line">        //     System.out.println();</span><br><span class="line">        // &#125;</span><br><span class="line">        dfs(s, 0);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(String s, int idx) &#123;</span><br><span class="line">        if (idx ==n) &#123;</span><br><span class="line">            ans.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = idx; i &lt; n; i++) &#123;</span><br><span class="line">            if (f[idx][i]) &#123;</span><br><span class="line">                list.add(s.substring(idx,i + 1));</span><br><span class="line">                dfs(s, i + 1);</span><br><span class="line">                list.remove(list.size() - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="638-大礼包"><a href="#638-大礼包" class="headerlink" title="638. 大礼包"></a>638. 大礼包</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    HashMap&lt;List&lt;Integer&gt;, Integer&gt; memo;   // 记忆化搜索存储已经查找到的答案&lt;需求列表，对应需求的价格&gt;</span><br><span class="line">    int n;                                  // 商品的数量</span><br><span class="line"></span><br><span class="line">    public int shoppingOffers(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; special, List&lt;Integer&gt; needs) &#123;</span><br><span class="line">        memo = new HashMap&lt;&gt;();</span><br><span class="line">        n = price.size();</span><br><span class="line"></span><br><span class="line">        // 筛选可以使价格降低的大礼包</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; filteredSpecial = new ArrayList&lt;&gt;();</span><br><span class="line">        //逐个检查所有的大礼包：大礼包中的商品数量&gt;0并且其价格低于单独购买的价格</span><br><span class="line">        for (List&lt;Integer&gt; sp : special) &#123;      // sp：n+1;前n个元素是大礼包中第i个商品的价格，第n+1个是大礼包的价格</span><br><span class="line">            int totalCount = 0, // 大礼包中的商品数量</span><br><span class="line">                TotalPrice = 0; // 单独购买大礼包中所有商品需要的价格</span><br><span class="line">            for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">                totalCount += sp.get(i);</span><br><span class="line">                TotalPrice += sp.get(i) * price.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            if (totalCount &gt; 0 &amp;&amp; TotalPrice &gt; sp.get(n)) &#123;</span><br><span class="line">                filteredSpecial.add(sp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;//至此，special中所有可以使价格降低的大礼包都被放入filteredSpecial中</span><br><span class="line"></span><br><span class="line">        // 记忆化搜索确定最便宜的价格</span><br><span class="line">        return dfs(price, special, needs);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int dfs(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; filteredSpecial, List&lt;Integer&gt; curNeeds) &#123;</span><br><span class="line">        if (!memo.containsKey(curNeeds))&#123;</span><br><span class="line">            int minPrice = 0;       // 购买所需商品的价格</span><br><span class="line">            for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">                minPrice += curNeeds.get(i) * price.get(i); // 不购买任何大礼包</span><br><span class="line">            &#125;</span><br><span class="line">            for (List&lt;Integer&gt; sp : filteredSpecial) &#123;  // 遍历所有大礼包</span><br><span class="line">                int specialPrice = sp.get(n);   // 当前大礼包的价格</span><br><span class="line">                List&lt;Integer&gt; nextNeeds = new ArrayList&lt;&gt;();</span><br><span class="line">                for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">                    if (sp.get(i) &gt; curNeeds.get(i)) &#123;  // 大礼包中某个商品的价格超过需求，不能购买</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nextNeeds.add(curNeeds.get(i) - sp.get(i)); // 剩余的需求</span><br><span class="line">                &#125;</span><br><span class="line">                if (nextNeeds.size() == n) &#123;    // 当前大礼包可以购买</span><br><span class="line">                    minPrice = Math.min(minPrice,   // 不购买当前大礼包的价格</span><br><span class="line">                                        dfs(price, filteredSpecial, nextNeeds) + specialPrice); // 购买当前大礼包的价格</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 当前需求已经考虑结束，可以将其价格加入结果集中</span><br><span class="line">            memo.put(curNeeds, minPrice);</span><br><span class="line">        &#125;</span><br><span class="line">        return memo.get(curNeeds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="784-字母大小全排列"><a href="#784-字母大小全排列" class="headerlink" title="784. 字母大小全排列"></a>784. 字母大小全排列</h2><p>   第一次做这个题目的时候因为粗心 把题目要求搞错，所以实际解决的问题是字符串元素的所有重排列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;String&gt; ans;</span><br><span class="line">    boolean[] visited;</span><br><span class="line">    public List&lt;String&gt; letterCasePermutation(String s) &#123;</span><br><span class="line">        ans = new ArrayList&lt;&gt;();</span><br><span class="line">        visited = new boolean[s.length()];</span><br><span class="line">        dfs(s, new StringBuffer());</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(String s, StringBuffer sb) &#123;</span><br><span class="line">        if (sb.length() == s.length())&#123;</span><br><span class="line">            ans.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            if (!visited[i]) &#123;</span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">                visited[i] = true;</span><br><span class="line">                dfs(s, sb);</span><br><span class="line">                sb.deleteCharAt(sb.length() - 1);</span><br><span class="line">                visited[i] = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>这里是这个问题的正确解答</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;String&gt; ans;</span><br><span class="line">    boolean[] visited;</span><br><span class="line">    public List&lt;String&gt; letterCasePermutation(String s) &#123;</span><br><span class="line">        ans = new ArrayList&lt;&gt;();</span><br><span class="line">        visited = new boolean[s.length()];</span><br><span class="line">        dfs(s, new StringBuffer(), 0);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(String s, StringBuffer sb, int index) &#123;</span><br><span class="line">        if (index == s.length()) &#123;</span><br><span class="line">            String string = sb.toString();</span><br><span class="line">            ans.add(string);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        char ch = s.charAt(index);</span><br><span class="line">        if (Character.isDigit(ch)) &#123;</span><br><span class="line">            sb.append(ch);</span><br><span class="line">            dfs(s, sb, index + 1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sb.append(ch);</span><br><span class="line">            dfs(s, sb, index + 1);</span><br><span class="line">            sb.deleteCharAt(sb.length() - 1);</span><br><span class="line">            sb.append(change(ch));</span><br><span class="line">            dfs(s, sb, index + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.deleteCharAt(sb.length() - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public char change(char c) &#123;</span><br><span class="line">        if (c &gt;= 65 &amp;&amp; c &lt;= 90) &#123;</span><br><span class="line">            return (char) (c + 32);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return (char) (c - 32);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;力扣刷题笔记，回溯算法&quot;&gt;&lt;a href=&quot;#力扣刷题笔记，回溯算法&quot; class=&quot;headerlink&quot; title=&quot;力扣刷题笔记，回溯算法&quot;&gt;&lt;/a&gt;力扣刷题笔记，回溯算法&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;回溯算法是一种常用的解决问题的思想，其本质是不断“试</summary>
      
    
    
    
    
    <category term="力扣刷题笔记, 算法" scheme="http://example.com/tags/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>力扣刷题笔记，8. 字符串整数转换</title>
    <link href="http://example.com/2022/02/22/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A8-%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A8/"/>
    <id>http://example.com/2022/02/22/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A8-%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A8/</id>
    <published>2022-02-22T13:03:21.000Z</published>
    <updated>2022-02-25T11:43:33.475Z</updated>
    
    <content type="html"><![CDATA[<h3 id="针对力扣第8题的思路和程序，重点学习JAVA实现自动机的写法。"><a href="#针对力扣第8题的思路和程序，重点学习JAVA实现自动机的写法。" class="headerlink" title="针对力扣第8题的思路和程序，重点学习JAVA实现自动机的写法。"></a>针对力扣第8题的思路和程序，重点学习JAVA实现自动机的写法。</h3><span id="more"></span><h2 id="1-自动机"><a href="#1-自动机" class="headerlink" title="1.自动机"></a>1.自动机</h2><pre><code>字符串中的数字为结果的条件是：这个数字（包含符号）的前面只有空格</code></pre><p>&amp;emsp;每次输入的字符包括四种情况：空格“ ”，符号“+&#x2F;-”，数字，其他。<br>同时对应有四种状态：<br> -开始状态(start)，即尚未读取到符号或者数字，只读取到空格或未读取<br> -符号状态(signed)，即在开始状态下读取到一个符号<br> -拼数字状态(in_number)，即在开始状态或者符号状态或者数字状态下又读取到一个数字<br> -结束状态(end)，即已经读完数字或者在开始状态下即读取到非数字且非符号，或者符号状态读取到非数字。</p><p>状态转移表如下：</p><table><thead><tr><th></th><th>“ “</th><th>+&#x2F;-</th><th>number</th><th>other</th></tr></thead><tbody><tr><td>start</td><td>start</td><td>sighed</td><td>in_number</td><td>end</td></tr><tr><td>signed</td><td>end</td><td>end</td><td>in_number</td><td>end</td></tr><tr><td>in_number</td><td>end</td><td>end</td><td>in_number</td><td>end</td></tr><tr><td>end</td><td>end</td><td>end</td><td>end</td><td>end</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int myAtoi(String s) &#123;</span><br><span class="line">        Automation automation = new Automation();</span><br><span class="line">        for (char c : s.toCharArray()) &#123;</span><br><span class="line">            automation.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return (int) (automation.sign * automation.ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Automation &#123;</span><br><span class="line">    enum States&#123;</span><br><span class="line">        START, SIGNED, IN_NUMBER, END;</span><br><span class="line">    &#125;</span><br><span class="line">    public int sign = 1;    // 结果的符号，如果读到有效的“-”,则变为-1</span><br><span class="line">    public long ans = 0;    // 用于存放得到的结果,始终是正数,long类型为了防止结果溢出</span><br><span class="line">    private States state = States.START;    // 表示状态，默认为开始状态</span><br><span class="line">    private Map&lt;States,States[]&gt; table = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public Automation() &#123;</span><br><span class="line">        // table 赋值,数组中对应输入分别为 空格“ ”，符号“+/-”，数字，其他 时的次状态</span><br><span class="line">        table.put(States.START, new States[] &#123;States.START, States.SIGNED, States.IN_NUMBER, States.END&#125;);</span><br><span class="line">        table.put(States.SIGNED, new States[] &#123;States.END, States.END, States.IN_NUMBER, States.END&#125;);</span><br><span class="line">        table.put(States.IN_NUMBER, new States[] &#123;States.END, States.END, States.IN_NUMBER, States.END&#125;);</span><br><span class="line">        table.put(States.END, new States[] &#123;States.END, States.END, States.END, States.END&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void get(char c) &#123;</span><br><span class="line">        // 根据当前状态和输入得到次状态</span><br><span class="line">        state = table.get(state)[getValue(c)];</span><br><span class="line">        // 只有次状态为数字或者符号的时候才会影响结果</span><br><span class="line">        if (state == States.IN_NUMBER) &#123;</span><br><span class="line">            ans = ans * 10 + c - &#x27;0&#x27;;</span><br><span class="line">            // 分正负结果分别处理结果溢出 </span><br><span class="line">            if (sign == 1) &#123;</span><br><span class="line">                ans = Math.min(ans, (long)Integer.MAX_VALUE);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ans = Math.min(ans, -(long)Integer.MIN_VALUE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (state == States.SIGNED) &#123;</span><br><span class="line">            sign = c == &#x27;+&#x27; ? 1 : -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getValue(char c) &#123;</span><br><span class="line">        if (c == &#x27; &#x27;)</span><br><span class="line">            return 0;</span><br><span class="line">        if (c == &#x27;+&#x27; || c == &#x27;-&#x27;)</span><br><span class="line">            return 1;</span><br><span class="line">        if (Character.isDigit(c))</span><br><span class="line">            return 2;</span><br><span class="line">        return 3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-直接模拟"><a href="#2-直接模拟" class="headerlink" title="2. 直接模拟"></a>2. 直接模拟</h2><pre><code>先使用API去掉前导和尾部空白，对剩下的进行判断：</code></pre><ol><li>如果开始是数字，则合法，修改结果，指针进一继续判断；</li><li>如果开始是符号，则合法，修改结果符号，指针进一继续判断；</li></ol><ul><li>如果是数字，则合法，修改结果，指针进一继续判断;</li><li>如果是其他，则非法，结束；</li></ul><ol start="3"><li>如果是其他，则非法，结束。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int myAtoi(String s) &#123;</span><br><span class="line">        String s1 = s.trim();   // 去掉s的前导和尾部空白</span><br><span class="line">        if (s1.length() &lt; 1)</span><br><span class="line">            return 0;</span><br><span class="line">        long ans = 0;           // long 类型防止溢出，恒为正值</span><br><span class="line">        int index = 0;          // 当前下标</span><br><span class="line">        int sign = 1;           // 符号</span><br><span class="line"></span><br><span class="line">        // s1 的首个字符三种可能</span><br><span class="line">        // 如果是+/-则修改符号，并下标右移</span><br><span class="line">        if (s1.charAt(index) == &#x27;+&#x27;) &#123;</span><br><span class="line">            sign = 1;</span><br><span class="line">            index ++;</span><br><span class="line">        &#125; else if (s1.charAt(index) == &#x27;-&#x27;) &#123;</span><br><span class="line">            sign = -1;</span><br><span class="line">            index ++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果是数字或者其他</span><br><span class="line">        for (int i = index; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            char c = s1.charAt(i);</span><br><span class="line">            // 如果是数字</span><br><span class="line">            if (Character.isDigit(c)) &#123;</span><br><span class="line">                ans = ans * 10 + c - &#x27;0&#x27;;</span><br><span class="line">                // 分类处理溢出</span><br><span class="line">                if (sign == 1) &#123;</span><br><span class="line">                    ans = Math.min(ans, Integer.MAX_VALUE);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    ans = Math.min(ans,-(long)Integer.MIN_VALUE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 如果是其他则结束返回结果</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return (int) (sign * ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;针对力扣第8题的思路和程序，重点学习JAVA实现自动机的写法。&quot;&gt;&lt;a href=&quot;#针对力扣第8题的思路和程序，重点学习JAVA实现自动机的写法。&quot; class=&quot;headerlink&quot; title=&quot;针对力扣第8题的思路和程序，重点学习JAVA实现自动机的写法。&quot;&gt;&lt;/a&gt;针对力扣第8题的思路和程序，重点学习JAVA实现自动机的写法。&lt;/h3&gt;</summary>
    
    
    
    
    <category term="力扣刷题笔记" scheme="http://example.com/tags/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>my first blog</title>
    <link href="http://example.com/2022/02/22/my-first-blog/"/>
    <id>http://example.com/2022/02/22/my-first-blog/</id>
    <published>2022-02-22T06:55:26.000Z</published>
    <updated>2022-02-22T08:16:32.848Z</updated>
    
    <content type="html"><![CDATA[<p>搭建个人博客的完整过程：</p><span id="more"></span><h1 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h1><h2 id="1-1-git"><a href="#1-1-git" class="headerlink" title="1.1 git"></a>1.1 git</h2><h2 id="1-2-nodejs"><a href="#1-2-nodejs" class="headerlink" title="1.2 nodejs"></a>1.2 nodejs</h2><h2 id="1-3-hexo"><a href="#1-3-hexo" class="headerlink" title="1.3 hexo"></a>1.3 hexo</h2><pre><code>    1.安装命令：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g</span><br></pre></td></tr></table></figure><pre><code>    2.测试是否安装成功</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><pre><code>    3.安装hexo依赖</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure><pre><code>    常用的hexo的基本命令</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure><h1 id="2-搭建博客"><a href="#2-搭建博客" class="headerlink" title="2. 搭建博客"></a>2. 搭建博客</h1><h2 id="2-1-创建一个文件夹用于保存博客，并进入这个文件夹中初始化个人博客"><a href="#2-1-创建一个文件夹用于保存博客，并进入这个文件夹中初始化个人博客" class="headerlink" title="2.1 创建一个文件夹用于保存博客，并进入这个文件夹中初始化个人博客"></a>2.1 创建一个文件夹用于保存博客，并进入这个文件夹中初始化个人博客</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><h2 id="2-2-生成静态网页"><a href="#2-2-生成静态网页" class="headerlink" title="2.2 生成静态网页"></a>2.2 生成静态网页</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><pre><code>预览</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><h2 id="2-3-部署到github"><a href="#2-3-部署到github" class="headerlink" title="2.3 部署到github"></a>2.3 部署到github</h2><pre><code>1. 新建一个github仓库 ，命名为：用户名.github.io2. 在博客存放目录在下找到_config.yml文件并编辑</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:LWWm/LWWm.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><pre><code>3. 发布到github，之后就可以在浏览器通过https://lwwm.github.io/访问</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><h2 id="2-4-编写博客"><a href="#2-4-编写博客" class="headerlink" title="2.4 编写博客"></a>2.4 编写博客</h2><pre><code>1. 新建名称为“my first blog”的博客</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &#x27;my first blog&#x27;</span><br></pre></td></tr></table></figure><pre><code>可以看到在Blogs\source\_posts目录下新生成了对应的.md文件，在其中可以编辑博客内容。2. 编写完成之后可以部署到github</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g      //生成html文件</span><br><span class="line">hexo d      //上传到github</span><br></pre></td></tr></table></figure><pre><code>3. 再次访问https://lwwm.github.io可以看到效果</code></pre><h1 id="3-曾经遇到的问题："><a href="#3-曾经遇到的问题：" class="headerlink" title="3. 曾经遇到的问题："></a>3. 曾经遇到的问题：</h1><h2 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h2><pre><code>博客上传到github的时候提示错误：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deployer not found: git</span><br></pre></td></tr></table></figure><pre><code>解决方法：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.cnblogs.com/chenlove/p/15058170.html">link</a>  <a href="https://www.cnblogs.com/chenlove/p/15058170.html">https://www.cnblogs.com/chenlove/p/15058170.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;搭建个人博客的完整过程：&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/02/22/hello-world/"/>
    <id>http://example.com/2022/02/22/hello-world/</id>
    <published>2022-02-22T06:27:19.784Z</published>
    <updated>2022-02-22T08:06:07.088Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><span id="more"></span><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
