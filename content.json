{"meta":{"title":"LWWm","subtitle":"","description":"若能美梦成真，何羡妖魔鬼神","author":"LWWm","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2022-02-23T08:08:43.000Z","updated":"2022-02-23T08:08:43.460Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-02-23T08:07:41.000Z","updated":"2022-02-23T08:08:34.280Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"力扣刷题笔记，回溯算法","slug":"力扣刷题笔记，回溯算法","date":"2022-02-25T11:34:10.000Z","updated":"2022-02-25T12:04:32.514Z","comments":true,"path":"2022/02/25/力扣刷题笔记，回溯算法/","link":"","permalink":"http://example.com/2022/02/25/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%8C%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/","excerpt":"","text":"力扣刷题笔记，回溯算法回溯算法是一种常用的解决问题的思想，其本质是不断“试错”，在正则表达式匹配、编译原理中的语法分析等实际的场景中都可以应用，还可以解决诸如数独、儿皇后、图的着色、全排列等数学问题。其模板程序如下： &lt;!--more--&gt; 123456789101112131415const visited = &#123;&#125;function dfs(i) &#123; if (满足特定条件）&#123; // 返回结果 or 退出搜索空间 &#125; visited[i] = true // 将当前状态标为已搜索 dosomething(i) // 对i做一些操作 for (根据i能到达的下个状态j) &#123; if (!visited[j]) &#123; // 如果状态j没有被搜索过 dfs(j) &#125; &#125; undo(i) // 恢复i&#125; 下面是回溯算法知识点的部分题解： 39. 组合总和1234567891011121314151617181920212223242526272829303132class Solution &#123; List&lt;List&lt;Integer&gt;&gt; ans; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; ans = new ArrayList&lt;&gt;(); dfs(candidates, target, new ArrayList&lt;&gt;(),0); return ans; &#125;/** * 依次查看数组中的所有元素，每次分为两种情况：考虑和不考虑，如果不考虑即直接跳过，下标直接+1， * 对于考虑的情况，因为元素可以重复使用，所以下一次的下标不变。 */ public void dfs(int[] candidates, int target, List&lt;Integer&gt; combine, int idx) &#123; if (idx ==candidates.length) &#123; return ; &#125; if (target == 0) &#123; ans.add(new ArrayList&lt;Integer&gt;(combine)); return; &#125; // 考虑当前元素 if (target - candidates[idx] &gt;= 0) &#123; combine.add(candidates[idx]); dfs(candidates, target - candidates[idx],combine, idx); combine.remove(combine.size() - 1); &#125; // 跳过当前元素 dfs(candidates, target, combine, idx + 1); &#125;&#125; 47. 全排列2123if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !vis[i - 1]) &#123; continue;&#125; 这个条件可以保证在已经排序的含有重复元素的中，每次填入的数字一定是这个数组中“从左到右第一个未被填入的数字”。假设我们有 33 个重复数排完序后相邻，那么我们一定保证每次都是拿从左往右第一个未被填过的数字，即整个数组的状态其实是保证了 [未填入，未填入，未填入] 到 [填入，未填入，未填入]，再到 [填入，填入，未填入]，最后到 [填入，填入，填入] 的过程的，因此可以达到去重的目标。 131. 分割回文串12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; List&lt;List&lt;String&gt;&gt; ans; List&lt;String&gt; list; int n; boolean[][] f; public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; n = s.length(); ans = new ArrayList&lt;&gt;(); list = new ArrayList&lt;&gt;(); f = new boolean[n][n]; for (int i = 0; i &lt; n; i++) &#123; Arrays.fill(f[i],true); &#125; for (int i = n - 1; i &gt;= 0; i--) &#123; for (int j = i + 1; j &lt; n; j++) &#123; f[i][j] = (s.charAt(i) == s.charAt(j)) &amp;&amp; f[i + 1][j - 1]; // System.out.println(i + &quot;&gt;&quot; + j +&quot;&gt;&quot;+ (s.charAt(i) == s.charAt(j)) + &quot;&gt;&quot;+ f[i + 1][j - 1] + &quot;&gt;&quot; + f[i][j]); &#125; &#125; // for (int i = 0; i &lt; n; i++) &#123; // for (int j = 0; j &lt; n; j++) &#123; // System.out.print(f[i][j] + &quot; &quot;); // &#125; // System.out.println(); // &#125; dfs(s, 0); return ans; &#125; public void dfs(String s, int idx) &#123; if (idx ==n) &#123; ans.add(new ArrayList&lt;&gt;(list)); return ; &#125; for (int i = idx; i &lt; n; i++) &#123; if (f[idx][i]) &#123; list.add(s.substring(idx,i + 1)); dfs(s, i + 1); list.remove(list.size() - 1); &#125; &#125; &#125;&#125; 638. 大礼包123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123; HashMap&lt;List&lt;Integer&gt;, Integer&gt; memo; // 记忆化搜索存储已经查找到的答案&lt;需求列表，对应需求的价格&gt; int n; // 商品的数量 public int shoppingOffers(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; special, List&lt;Integer&gt; needs) &#123; memo = new HashMap&lt;&gt;(); n = price.size(); // 筛选可以使价格降低的大礼包 List&lt;List&lt;Integer&gt;&gt; filteredSpecial = new ArrayList&lt;&gt;(); //逐个检查所有的大礼包：大礼包中的商品数量&gt;0并且其价格低于单独购买的价格 for (List&lt;Integer&gt; sp : special) &#123; // sp：n+1;前n个元素是大礼包中第i个商品的价格，第n+1个是大礼包的价格 int totalCount = 0, // 大礼包中的商品数量 TotalPrice = 0; // 单独购买大礼包中所有商品需要的价格 for (int i = 0; i &lt; n; i++) &#123; totalCount += sp.get(i); TotalPrice += sp.get(i) * price.get(i); &#125; if (totalCount &gt; 0 &amp;&amp; TotalPrice &gt; sp.get(n)) &#123; filteredSpecial.add(sp); &#125; &#125;//至此，special中所有可以使价格降低的大礼包都被放入filteredSpecial中 // 记忆化搜索确定最便宜的价格 return dfs(price, special, needs); &#125; public int dfs(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; filteredSpecial, List&lt;Integer&gt; curNeeds) &#123; if (!memo.containsKey(curNeeds))&#123; int minPrice = 0; // 购买所需商品的价格 for (int i = 0; i &lt; n; i++) &#123; minPrice += curNeeds.get(i) * price.get(i); // 不购买任何大礼包 &#125; for (List&lt;Integer&gt; sp : filteredSpecial) &#123; // 遍历所有大礼包 int specialPrice = sp.get(n); // 当前大礼包的价格 List&lt;Integer&gt; nextNeeds = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) &#123; if (sp.get(i) &gt; curNeeds.get(i)) &#123; // 大礼包中某个商品的价格超过需求，不能购买 break; &#125; nextNeeds.add(curNeeds.get(i) - sp.get(i)); // 剩余的需求 &#125; if (nextNeeds.size() == n) &#123; // 当前大礼包可以购买 minPrice = Math.min(minPrice, // 不购买当前大礼包的价格 dfs(price, filteredSpecial, nextNeeds) + specialPrice); // 购买当前大礼包的价格 &#125; &#125; // 当前需求已经考虑结束，可以将其价格加入结果集中 memo.put(curNeeds, minPrice); &#125; return memo.get(curNeeds); &#125;&#125; 784. 字母大小全排列 第一次做这个题目的时候因为粗心 把题目要求搞错，所以实际解决的问题是字符串元素的所有重排列。 12345678910111213141516171819202122232425class Solution &#123; List&lt;String&gt; ans; boolean[] visited; public List&lt;String&gt; letterCasePermutation(String s) &#123; ans = new ArrayList&lt;&gt;(); visited = new boolean[s.length()]; dfs(s, new StringBuffer()); return ans; &#125; public void dfs(String s, StringBuffer sb) &#123; if (sb.length() == s.length())&#123; ans.add(sb.toString()); &#125; for (int i = 0; i &lt; s.length(); i++) &#123; if (!visited[i]) &#123; sb.append(s.charAt(i)); visited[i] = true; dfs(s, sb); sb.deleteCharAt(sb.length() - 1); visited[i] = false; &#125; &#125; &#125;&#125; 这里是这个问题的正确解答 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; List&lt;String&gt; ans; boolean[] visited; public List&lt;String&gt; letterCasePermutation(String s) &#123; ans = new ArrayList&lt;&gt;(); visited = new boolean[s.length()]; dfs(s, new StringBuffer(), 0); return ans; &#125; public void dfs(String s, StringBuffer sb, int index) &#123; if (index == s.length()) &#123; String string = sb.toString(); ans.add(string); return; &#125; char ch = s.charAt(index); if (Character.isDigit(ch)) &#123; sb.append(ch); dfs(s, sb, index + 1); &#125; else &#123; sb.append(ch); dfs(s, sb, index + 1); sb.deleteCharAt(sb.length() - 1); sb.append(change(ch)); dfs(s, sb, index + 1); &#125; sb.deleteCharAt(sb.length() - 1); &#125; public char change(char c) &#123; if (c &gt;= 65 &amp;&amp; c &lt;= 90) &#123; return (char) (c + 32); &#125; else &#123; return (char) (c - 32); &#125; &#125;&#125;","categories":[],"tags":[{"name":"力扣刷题笔记","slug":"力扣刷题笔记","permalink":"http://example.com/tags/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"力扣刷题笔记，8. 字符串整数转换","slug":"力扣刷题笔记：8-力扣刷题笔记：8","date":"2022-02-22T13:03:21.000Z","updated":"2022-02-25T11:43:33.475Z","comments":true,"path":"2022/02/22/力扣刷题笔记：8-力扣刷题笔记：8/","link":"","permalink":"http://example.com/2022/02/22/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A8-%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A8/","excerpt":"针对力扣第8题的思路和程序，重点学习JAVA实现自动机的写法。","text":"针对力扣第8题的思路和程序，重点学习JAVA实现自动机的写法。 1.自动机字符串中的数字为结果的条件是：这个数字（包含符号）的前面只有空格 &amp;emsp;每次输入的字符包括四种情况：空格“ ”，符号“+&#x2F;-”，数字，其他。同时对应有四种状态： -开始状态(start)，即尚未读取到符号或者数字，只读取到空格或未读取 -符号状态(signed)，即在开始状态下读取到一个符号 -拼数字状态(in_number)，即在开始状态或者符号状态或者数字状态下又读取到一个数字 -结束状态(end)，即已经读完数字或者在开始状态下即读取到非数字且非符号，或者符号状态读取到非数字。 状态转移表如下： “ “ +&#x2F;- number other start start sighed in_number end signed end end in_number end in_number end end in_number end end end end end end 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123; public int myAtoi(String s) &#123; Automation automation = new Automation(); for (char c : s.toCharArray()) &#123; automation.get(c); &#125; return (int) (automation.sign * automation.ans); &#125;&#125;class Automation &#123; enum States&#123; START, SIGNED, IN_NUMBER, END; &#125; public int sign = 1; // 结果的符号，如果读到有效的“-”,则变为-1 public long ans = 0; // 用于存放得到的结果,始终是正数,long类型为了防止结果溢出 private States state = States.START; // 表示状态，默认为开始状态 private Map&lt;States,States[]&gt; table = new HashMap&lt;&gt;(); public Automation() &#123; // table 赋值,数组中对应输入分别为 空格“ ”，符号“+/-”，数字，其他 时的次状态 table.put(States.START, new States[] &#123;States.START, States.SIGNED, States.IN_NUMBER, States.END&#125;); table.put(States.SIGNED, new States[] &#123;States.END, States.END, States.IN_NUMBER, States.END&#125;); table.put(States.IN_NUMBER, new States[] &#123;States.END, States.END, States.IN_NUMBER, States.END&#125;); table.put(States.END, new States[] &#123;States.END, States.END, States.END, States.END&#125;); &#125; public void get(char c) &#123; // 根据当前状态和输入得到次状态 state = table.get(state)[getValue(c)]; // 只有次状态为数字或者符号的时候才会影响结果 if (state == States.IN_NUMBER) &#123; ans = ans * 10 + c - &#x27;0&#x27;; // 分正负结果分别处理结果溢出 if (sign == 1) &#123; ans = Math.min(ans, (long)Integer.MAX_VALUE); &#125; else &#123; ans = Math.min(ans, -(long)Integer.MIN_VALUE); &#125; &#125; else if (state == States.SIGNED) &#123; sign = c == &#x27;+&#x27; ? 1 : -1; &#125; &#125; public int getValue(char c) &#123; if (c == &#x27; &#x27;) return 0; if (c == &#x27;+&#x27; || c == &#x27;-&#x27;) return 1; if (Character.isDigit(c)) return 2; return 3; &#125;&#125; 2. 直接模拟先使用API去掉前导和尾部空白，对剩下的进行判断： 如果开始是数字，则合法，修改结果，指针进一继续判断； 如果开始是符号，则合法，修改结果符号，指针进一继续判断； 如果是数字，则合法，修改结果，指针进一继续判断; 如果是其他，则非法，结束； 如果是其他，则非法，结束。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int myAtoi(String s) &#123; String s1 = s.trim(); // 去掉s的前导和尾部空白 if (s1.length() &lt; 1) return 0; long ans = 0; // long 类型防止溢出，恒为正值 int index = 0; // 当前下标 int sign = 1; // 符号 // s1 的首个字符三种可能 // 如果是+/-则修改符号，并下标右移 if (s1.charAt(index) == &#x27;+&#x27;) &#123; sign = 1; index ++; &#125; else if (s1.charAt(index) == &#x27;-&#x27;) &#123; sign = -1; index ++; &#125; // 如果是数字或者其他 for (int i = index; i &lt; s1.length(); i++) &#123; char c = s1.charAt(i); // 如果是数字 if (Character.isDigit(c)) &#123; ans = ans * 10 + c - &#x27;0&#x27;; // 分类处理溢出 if (sign == 1) &#123; ans = Math.min(ans, Integer.MAX_VALUE); &#125; else &#123; ans = Math.min(ans,-(long)Integer.MIN_VALUE); &#125; &#125; else &#123; // 如果是其他则结束返回结果 break; &#125; &#125; return (int) (sign * ans); &#125;&#125;","categories":[],"tags":[{"name":"力扣刷题笔记","slug":"力扣刷题笔记","permalink":"http://example.com/tags/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}]},{"title":"my first blog","slug":"my-first-blog","date":"2022-02-22T06:55:26.000Z","updated":"2022-02-22T08:16:32.848Z","comments":true,"path":"2022/02/22/my-first-blog/","link":"","permalink":"http://example.com/2022/02/22/my-first-blog/","excerpt":"搭建个人博客的完整过程：","text":"搭建个人博客的完整过程： 1. 环境准备1.1 git1.2 nodejs1.3 hexo 1.安装命令： 1npm install hexo -g 2.测试是否安装成功 1hexo -v 3.安装hexo依赖 1npm install --save hexo-deployer-git 常用的hexo的基本命令 1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 2. 搭建博客2.1 创建一个文件夹用于保存博客，并进入这个文件夹中初始化个人博客1hexo init 2.2 生成静态网页1hexo g 预览 1hexo s 2.3 部署到github1. 新建一个github仓库 ，命名为：用户名.github.io 2. 在博客存放目录在下找到_config.yml文件并编辑 1234deploy: type: git repository: git@github.com:LWWm/LWWm.github.io.git branch: main 3. 发布到github，之后就可以在浏览器通过https://lwwm.github.io/访问 1hexo d 2.4 编写博客1. 新建名称为“my first blog”的博客 1hexo new &#x27;my first blog&#x27; 可以看到在Blogs\\source\\_posts目录下新生成了对应的.md文件，在其中可以编辑博客内容。 2. 编写完成之后可以部署到github 12hexo g //生成html文件hexo d //上传到github 3. 再次访问https://lwwm.github.io可以看到效果 3. 曾经遇到的问题：3.1博客上传到github的时候提示错误： 1Deployer not found: git 解决方法： 1npm install --save hexo-deployer-git 参考link https://www.cnblogs.com/chenlove/p/15058170.html","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-02-22T06:27:19.784Z","updated":"2022-02-22T08:06:07.088Z","comments":true,"path":"2022/02/22/hello-world/","link":"","permalink":"http://example.com/2022/02/22/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"力扣刷题笔记","slug":"力扣刷题笔记","permalink":"http://example.com/tags/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]}