<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>my first blog</title>
    <url>/2022/02/22/my-first-blog/</url>
    <content><![CDATA[<p>搭建个人博客的完整过程：</p>
<span id="more"></span>


<h1 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h1><h2 id="1-1-git"><a href="#1-1-git" class="headerlink" title="1.1 git"></a>1.1 git</h2><h2 id="1-2-nodejs"><a href="#1-2-nodejs" class="headerlink" title="1.2 nodejs"></a>1.2 nodejs</h2><h2 id="1-3-hexo"><a href="#1-3-hexo" class="headerlink" title="1.3 hexo"></a>1.3 hexo</h2><pre><code>    1.安装命令：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo -g</span><br></pre></td></tr></table></figure>
<pre><code>    2.测试是否安装成功
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure>
<pre><code>    3.安装hexo依赖
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>

<pre><code>    常用的hexo的基本命令
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure>

<h1 id="2-搭建博客"><a href="#2-搭建博客" class="headerlink" title="2. 搭建博客"></a>2. 搭建博客</h1><h2 id="2-1-创建一个文件夹用于保存博客，并进入这个文件夹中初始化个人博客"><a href="#2-1-创建一个文件夹用于保存博客，并进入这个文件夹中初始化个人博客" class="headerlink" title="2.1 创建一个文件夹用于保存博客，并进入这个文件夹中初始化个人博客"></a>2.1 创建一个文件夹用于保存博客，并进入这个文件夹中初始化个人博客</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<h2 id="2-2-生成静态网页"><a href="#2-2-生成静态网页" class="headerlink" title="2.2 生成静态网页"></a>2.2 生成静态网页</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<pre><code>预览
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<h2 id="2-3-部署到github"><a href="#2-3-部署到github" class="headerlink" title="2.3 部署到github"></a>2.3 部署到github</h2><pre><code>1. 新建一个github仓库 ，命名为：用户名.github.io
2. 在博客存放目录在下找到_config.yml文件并编辑
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:LWWm/LWWm.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>
<pre><code>3. 发布到github，之后就可以在浏览器通过https://lwwm.github.io/访问
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<h2 id="2-4-编写博客"><a href="#2-4-编写博客" class="headerlink" title="2.4 编写博客"></a>2.4 编写博客</h2><pre><code>1. 新建名称为“my first blog”的博客
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &#x27;my first blog&#x27;</span><br></pre></td></tr></table></figure>
<pre><code>可以看到在Blogs\source\_posts目录下新生成了对应的.md文件，在其中可以编辑博客内容。
2. 编写完成之后可以部署到github
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g      //生成html文件</span><br><span class="line">hexo d      //上传到github</span><br></pre></td></tr></table></figure>
<pre><code>3. 再次访问https://lwwm.github.io可以看到效果
</code></pre>
<h1 id="3-曾经遇到的问题："><a href="#3-曾经遇到的问题：" class="headerlink" title="3. 曾经遇到的问题："></a>3. 曾经遇到的问题：</h1><h2 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h2><pre><code>博客上传到github的时候提示错误：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Deployer not found: git</span><br></pre></td></tr></table></figure>
<pre><code>解决方法：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>


<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.cnblogs.com/chenlove/p/15058170.html">link</a>  <a href="https://www.cnblogs.com/chenlove/p/15058170.html">https://www.cnblogs.com/chenlove/p/15058170.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/02/22/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><span id="more"></span>

<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>力扣刷题笔记，回溯算法</title>
    <url>/2022/02/25/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%8C%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="力扣刷题笔记，回溯算法"><a href="#力扣刷题笔记，回溯算法" class="headerlink" title="力扣刷题笔记，回溯算法"></a>力扣刷题笔记，回溯算法</h1><p>回溯算法是一种常用的解决问题的思想，其本质是不断“试错”，在正则表达式匹配、编译原理中的语法分析等实际的场景中都可以应用，还可以解决诸如数独、八皇后、图的着色、全排列等数学问题。<br>其模板程序如下：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const visited = &#123;&#125;</span><br><span class="line">function dfs(i) &#123;</span><br><span class="line">    if (满足特定条件）&#123;</span><br><span class="line">        // 返回结果 or 退出搜索空间</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    visited[i] = true // 将当前状态标为已搜索</span><br><span class="line">    dosomething(i) // 对i做一些操作</span><br><span class="line">    for (根据i能到达的下个状态j) &#123;</span><br><span class="line">        if (!visited[j]) &#123; // 如果状态j没有被搜索过</span><br><span class="line">            dfs(j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    undo(i) // 恢复i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是回溯算法知识点的部分题解：</p>
<h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line">        ans = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(candidates, target, new ArrayList&lt;&gt;(),0);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 依次查看数组中的所有元素，每次分为两种情况：考虑和不考虑，如果不考虑即直接跳过，下标直接+1，</span><br><span class="line"> *        对于考虑的情况，因为元素可以重复使用，所以下一次的下标不变。</span><br><span class="line"> */</span><br><span class="line">    public void dfs(int[] candidates, int target, List&lt;Integer&gt; combine, int idx) &#123;</span><br><span class="line">        if (idx ==candidates.length) &#123;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        if (target == 0) &#123;</span><br><span class="line">            ans.add(new ArrayList&lt;Integer&gt;(combine));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 考虑当前元素</span><br><span class="line">        if (target - candidates[idx] &gt;= 0) &#123;</span><br><span class="line">            combine.add(candidates[idx]);</span><br><span class="line">            dfs(candidates, target - candidates[idx],combine, idx);</span><br><span class="line">            combine.remove(combine.size() - 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 跳过当前元素</span><br><span class="line">        dfs(candidates, target, combine, idx + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="47-全排列2"><a href="#47-全排列2" class="headerlink" title="47. 全排列2"></a>47. 全排列2</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !vis[i - 1]) &#123;</span><br><span class="line">    continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个条件可以保证在已经排序的含有重复元素的中，每次填入的数字一定是这个数组中“从左到右第一个未被填入的数字”。假设我们有 33 个重复数排完序后相邻，那么我们一定保证每次都是拿从左往右第一个未被填过的数字，即整个数组的状态其实是保证了 [未填入，未填入，未填入] 到 [填入，未填入，未填入]，再到 [填入，填入，未填入]，最后到 [填入，填入，填入] 的过程的，因此可以达到去重的目标。</p>
<h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a>131. 分割回文串</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; ans;</span><br><span class="line">    List&lt;String&gt; list;</span><br><span class="line">    int n;</span><br><span class="line">    boolean[][] f;</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        n = s.length();</span><br><span class="line">        ans = new ArrayList&lt;&gt;();</span><br><span class="line">        list = new ArrayList&lt;&gt;();</span><br><span class="line">        f = new boolean[n][n];</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            Arrays.fill(f[i],true);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = n - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; n; j++) &#123;</span><br><span class="line">                f[i][j] = (s.charAt(i) == s.charAt(j)) &amp;&amp; f[i + 1][j - 1];</span><br><span class="line">                // System.out.println(i + &quot;&gt;&quot; + j +&quot;&gt;&quot;+ (s.charAt(i) == s.charAt(j)) + &quot;&gt;&quot;+ f[i + 1][j - 1] + &quot;&gt;&quot; + f[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        //     for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">        //         System.out.print(f[i][j] + &quot;   &quot;);</span><br><span class="line">        //     &#125;</span><br><span class="line">        //     System.out.println();</span><br><span class="line">        // &#125;</span><br><span class="line">        dfs(s, 0);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(String s, int idx) &#123;</span><br><span class="line">        if (idx ==n) &#123;</span><br><span class="line">            ans.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = idx; i &lt; n; i++) &#123;</span><br><span class="line">            if (f[idx][i]) &#123;</span><br><span class="line">                list.add(s.substring(idx,i + 1));</span><br><span class="line">                dfs(s, i + 1);</span><br><span class="line">                list.remove(list.size() - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="638-大礼包"><a href="#638-大礼包" class="headerlink" title="638. 大礼包"></a>638. 大礼包</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    HashMap&lt;List&lt;Integer&gt;, Integer&gt; memo;   // 记忆化搜索存储已经查找到的答案&lt;需求列表，对应需求的价格&gt;</span><br><span class="line">    int n;                                  // 商品的数量</span><br><span class="line"></span><br><span class="line">    public int shoppingOffers(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; special, List&lt;Integer&gt; needs) &#123;</span><br><span class="line">        memo = new HashMap&lt;&gt;();</span><br><span class="line">        n = price.size();</span><br><span class="line"></span><br><span class="line">        // 筛选可以使价格降低的大礼包</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; filteredSpecial = new ArrayList&lt;&gt;();</span><br><span class="line">        //逐个检查所有的大礼包：大礼包中的商品数量&gt;0并且其价格低于单独购买的价格</span><br><span class="line">        for (List&lt;Integer&gt; sp : special) &#123;      // sp：n+1;前n个元素是大礼包中第i个商品的价格，第n+1个是大礼包的价格</span><br><span class="line">            int totalCount = 0, // 大礼包中的商品数量</span><br><span class="line">                TotalPrice = 0; // 单独购买大礼包中所有商品需要的价格</span><br><span class="line">            for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">                totalCount += sp.get(i);</span><br><span class="line">                TotalPrice += sp.get(i) * price.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            if (totalCount &gt; 0 &amp;&amp; TotalPrice &gt; sp.get(n)) &#123;</span><br><span class="line">                filteredSpecial.add(sp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;//至此，special中所有可以使价格降低的大礼包都被放入filteredSpecial中</span><br><span class="line"></span><br><span class="line">        // 记忆化搜索确定最便宜的价格</span><br><span class="line">        return dfs(price, special, needs);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int dfs(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; filteredSpecial, List&lt;Integer&gt; curNeeds) &#123;</span><br><span class="line">        if (!memo.containsKey(curNeeds))&#123;</span><br><span class="line">            int minPrice = 0;       // 购买所需商品的价格</span><br><span class="line">            for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">                minPrice += curNeeds.get(i) * price.get(i); // 不购买任何大礼包</span><br><span class="line">            &#125;</span><br><span class="line">            for (List&lt;Integer&gt; sp : filteredSpecial) &#123;  // 遍历所有大礼包</span><br><span class="line">                int specialPrice = sp.get(n);   // 当前大礼包的价格</span><br><span class="line">                List&lt;Integer&gt; nextNeeds = new ArrayList&lt;&gt;();</span><br><span class="line">                for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">                    if (sp.get(i) &gt; curNeeds.get(i)) &#123;  // 大礼包中某个商品的价格超过需求，不能购买</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nextNeeds.add(curNeeds.get(i) - sp.get(i)); // 剩余的需求</span><br><span class="line">                &#125;</span><br><span class="line">                if (nextNeeds.size() == n) &#123;    // 当前大礼包可以购买</span><br><span class="line">                    minPrice = Math.min(minPrice,   // 不购买当前大礼包的价格</span><br><span class="line">                                        dfs(price, filteredSpecial, nextNeeds) + specialPrice); // 购买当前大礼包的价格</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 当前需求已经考虑结束，可以将其价格加入结果集中</span><br><span class="line">            memo.put(curNeeds, minPrice);</span><br><span class="line">        &#125;</span><br><span class="line">        return memo.get(curNeeds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="784-字母大小全排列"><a href="#784-字母大小全排列" class="headerlink" title="784. 字母大小全排列"></a>784. 字母大小全排列</h2><p>   第一次做这个题目的时候因为粗心 把题目要求搞错，所以实际解决的问题是字符串元素的所有重排列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;String&gt; ans;</span><br><span class="line">    boolean[] visited;</span><br><span class="line">    public List&lt;String&gt; letterCasePermutation(String s) &#123;</span><br><span class="line">        ans = new ArrayList&lt;&gt;();</span><br><span class="line">        visited = new boolean[s.length()];</span><br><span class="line">        dfs(s, new StringBuffer());</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(String s, StringBuffer sb) &#123;</span><br><span class="line">        if (sb.length() == s.length())&#123;</span><br><span class="line">            ans.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            if (!visited[i]) &#123;</span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">                visited[i] = true;</span><br><span class="line">                dfs(s, sb);</span><br><span class="line">                sb.deleteCharAt(sb.length() - 1);</span><br><span class="line">                visited[i] = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>这里是这个问题的正确解答
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;String&gt; ans;</span><br><span class="line">    boolean[] visited;</span><br><span class="line">    public List&lt;String&gt; letterCasePermutation(String s) &#123;</span><br><span class="line">        ans = new ArrayList&lt;&gt;();</span><br><span class="line">        visited = new boolean[s.length()];</span><br><span class="line">        dfs(s, new StringBuffer(), 0);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(String s, StringBuffer sb, int index) &#123;</span><br><span class="line">        if (index == s.length()) &#123;</span><br><span class="line">            String string = sb.toString();</span><br><span class="line">            ans.add(string);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        char ch = s.charAt(index);</span><br><span class="line">        if (Character.isDigit(ch)) &#123;</span><br><span class="line">            sb.append(ch);</span><br><span class="line">            dfs(s, sb, index + 1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sb.append(ch);</span><br><span class="line">            dfs(s, sb, index + 1);</span><br><span class="line">            sb.deleteCharAt(sb.length() - 1);</span><br><span class="line">            sb.append(change(ch));</span><br><span class="line">            dfs(s, sb, index + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.deleteCharAt(sb.length() - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public char change(char c) &#123;</span><br><span class="line">        if (c &gt;= 65 &amp;&amp; c &lt;= 90) &#123;</span><br><span class="line">            return (char) (c + 32);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return (char) (c - 32);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>力扣刷题笔记</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣刷题笔记，8. 字符串整数转换</title>
    <url>/2022/02/22/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A8.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h3 id="针对力扣第8题的思路和程序，重点学习JAVA实现自动机的写法。"><a href="#针对力扣第8题的思路和程序，重点学习JAVA实现自动机的写法。" class="headerlink" title="针对力扣第8题的思路和程序，重点学习JAVA实现自动机的写法。"></a>针对力扣第8题的思路和程序，重点学习JAVA实现自动机的写法。</h3><span id="more"></span>

<h2 id="1-自动机"><a href="#1-自动机" class="headerlink" title="1.自动机"></a>1.自动机</h2><pre><code>字符串中的数字为结果的条件是：这个数字（包含符号）的前面只有空格
</code></pre>
<p>&amp;emsp;每次输入的字符包括四种情况：空格“ ”，符号“+&#x2F;-”，数字，其他。<br>同时对应有四种状态：<br> -开始状态(start)，即尚未读取到符号或者数字，只读取到空格或未读取<br> -符号状态(signed)，即在开始状态下读取到一个符号<br> -拼数字状态(in_number)，即在开始状态或者符号状态或者数字状态下又读取到一个数字<br> -结束状态(end)，即已经读完数字或者在开始状态下即读取到非数字且非符号，或者符号状态读取到非数字。</p>
<p>状态转移表如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>“ “</th>
<th>+&#x2F;-</th>
<th>number</th>
<th>other</th>
</tr>
</thead>
<tbody><tr>
<td>start</td>
<td>start</td>
<td>sighed</td>
<td>in_number</td>
<td>end</td>
</tr>
<tr>
<td>signed</td>
<td>end</td>
<td>end</td>
<td>in_number</td>
<td>end</td>
</tr>
<tr>
<td>in_number</td>
<td>end</td>
<td>end</td>
<td>in_number</td>
<td>end</td>
</tr>
<tr>
<td>end</td>
<td>end</td>
<td>end</td>
<td>end</td>
<td>end</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int myAtoi(String s) &#123;</span><br><span class="line">        Automation automation = new Automation();</span><br><span class="line">        for (char c : s.toCharArray()) &#123;</span><br><span class="line">            automation.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return (int) (automation.sign * automation.ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Automation &#123;</span><br><span class="line">    enum States&#123;</span><br><span class="line">        START, SIGNED, IN_NUMBER, END;</span><br><span class="line">    &#125;</span><br><span class="line">    public int sign = 1;    // 结果的符号，如果读到有效的“-”,则变为-1</span><br><span class="line">    public long ans = 0;    // 用于存放得到的结果,始终是正数,long类型为了防止结果溢出</span><br><span class="line">    private States state = States.START;    // 表示状态，默认为开始状态</span><br><span class="line">    private Map&lt;States,States[]&gt; table = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public Automation() &#123;</span><br><span class="line">        // table 赋值,数组中对应输入分别为 空格“ ”，符号“+/-”，数字，其他 时的次状态</span><br><span class="line">        table.put(States.START, new States[] &#123;States.START, States.SIGNED, States.IN_NUMBER, States.END&#125;);</span><br><span class="line">        table.put(States.SIGNED, new States[] &#123;States.END, States.END, States.IN_NUMBER, States.END&#125;);</span><br><span class="line">        table.put(States.IN_NUMBER, new States[] &#123;States.END, States.END, States.IN_NUMBER, States.END&#125;);</span><br><span class="line">        table.put(States.END, new States[] &#123;States.END, States.END, States.END, States.END&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void get(char c) &#123;</span><br><span class="line">        // 根据当前状态和输入得到次状态</span><br><span class="line">        state = table.get(state)[getValue(c)];</span><br><span class="line">        // 只有次状态为数字或者符号的时候才会影响结果</span><br><span class="line">        if (state == States.IN_NUMBER) &#123;</span><br><span class="line">            ans = ans * 10 + c - &#x27;0&#x27;;</span><br><span class="line">            // 分正负结果分别处理结果溢出 </span><br><span class="line">            if (sign == 1) &#123;</span><br><span class="line">                ans = Math.min(ans, (long)Integer.MAX_VALUE);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ans = Math.min(ans, -(long)Integer.MIN_VALUE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (state == States.SIGNED) &#123;</span><br><span class="line">            sign = c == &#x27;+&#x27; ? 1 : -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getValue(char c) &#123;</span><br><span class="line">        if (c == &#x27; &#x27;)</span><br><span class="line">            return 0;</span><br><span class="line">        if (c == &#x27;+&#x27; || c == &#x27;-&#x27;)</span><br><span class="line">            return 1;</span><br><span class="line">        if (Character.isDigit(c))</span><br><span class="line">            return 2;</span><br><span class="line">        return 3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-直接模拟"><a href="#2-直接模拟" class="headerlink" title="2. 直接模拟"></a>2. 直接模拟</h2><pre><code>先使用API去掉前导和尾部空白，对剩下的进行判断：
</code></pre>
<ol>
<li>如果开始是数字，则合法，修改结果，指针进一继续判断；</li>
<li>如果开始是符号，则合法，修改结果符号，指针进一继续判断；</li>
</ol>
<ul>
<li>如果是数字，则合法，修改结果，指针进一继续判断;</li>
<li>如果是其他，则非法，结束；</li>
</ul>
<ol start="3">
<li>如果是其他，则非法，结束。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int myAtoi(String s) &#123;</span><br><span class="line">        String s1 = s.trim();   // 去掉s的前导和尾部空白</span><br><span class="line">        if (s1.length() &lt; 1)</span><br><span class="line">            return 0;</span><br><span class="line">        long ans = 0;           // long 类型防止溢出，恒为正值</span><br><span class="line">        int index = 0;          // 当前下标</span><br><span class="line">        int sign = 1;           // 符号</span><br><span class="line"></span><br><span class="line">        // s1 的首个字符三种可能</span><br><span class="line">        // 如果是+/-则修改符号，并下标右移</span><br><span class="line">        if (s1.charAt(index) == &#x27;+&#x27;) &#123;</span><br><span class="line">            sign = 1;</span><br><span class="line">            index ++;</span><br><span class="line">        &#125; else if (s1.charAt(index) == &#x27;-&#x27;) &#123;</span><br><span class="line">            sign = -1;</span><br><span class="line">            index ++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果是数字或者其他</span><br><span class="line">        for (int i = index; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            char c = s1.charAt(i);</span><br><span class="line">            // 如果是数字</span><br><span class="line">            if (Character.isDigit(c)) &#123;</span><br><span class="line">                ans = ans * 10 + c - &#x27;0&#x27;;</span><br><span class="line">                // 分类处理溢出</span><br><span class="line">                if (sign == 1) &#123;</span><br><span class="line">                    ans = Math.min(ans, Integer.MAX_VALUE);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    ans = Math.min(ans,-(long)Integer.MIN_VALUE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 如果是其他则结束返回结果</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return (int) (sign * ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>力扣刷题笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣刷题笔记：股票问题（一）</title>
    <url>/2022/02/27/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="股票问题（一）"><a href="#股票问题（一）" class="headerlink" title="股票问题（一）"></a>股票问题（一）</h1><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121.买卖股票的最佳时机"></a>121.买卖股票的最佳时机</h2><p>应当这样理解本题：</p>
<ol>
<li>只要某天的股票价格高于买入的价格，那么就可以考虑卖出股票，如果以后有更好的方案则改变方案；<span id="more"></span></li>
<li>假如我打算在某天卖出股票，那么一定当股票是在其价格最低点买入的时候，利润才是最大的；</li>
<li>如果在今天之前的价格都高于当前价格，则考虑今天才买入，如果未来卖出，一定比之前任意一天买入的利润要高。<br>综上，任意一天需要考虑的应当是两个值：之前的最低价格和当前价格，当当前价格高于最低价格时考虑卖出，否则更新最低价格。<br>第一天的时候只能买入，不可卖出。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int profit = 0; // 最大利润</span><br><span class="line">        int minValue = prices[0];</span><br><span class="line">        for (int i : prices) &#123;</span><br><span class="line">            if (i &lt;= minValue) &#123;    //第一天的价格等于最低价，修改最低价格，所以下标可以从0开始</span><br><span class="line">                minValue = i;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                profit = Math.max(profit, i - minValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="122-买卖股票的最佳时机Ⅱ"><a href="#122-买卖股票的最佳时机Ⅱ" class="headerlink" title="122. 买卖股票的最佳时机Ⅱ"></a>122. 买卖股票的最佳时机Ⅱ</h2><h2 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a>714. 买卖股票的最佳时机含手续费</h2><p>这两个题完全可以合并在一起，因为思路是一样的，<code>122</code>题只是<code>714</code>题中手续费为<code>0</code>的特殊情况。</p>
<h4 id="1-贪心算法"><a href="#1-贪心算法" class="headerlink" title="1.贪心算法"></a>1.贪心算法</h4><p>此处贪心算法的本质是允许后悔，即只要当前的价格可以产生利润，那就卖出，如果之后发现有更好的利润的时候就改变卖出的时机，换取更多的利润。重点在于，由于每次卖出之后允许后悔，即相当于每次卖出之后可以立即以当天的股票价格再买入股票（无需手续费），如果某天的股价加上手续费还低于手中股票的购入的费用，则可以重新购入股票，注意当天的股价应当包括手续费；如果某天的股价（包括手续费）等于买入价格，则不作处理，因为可能意味着多一次的手续费。</p>
<p>对于“由于每次卖出之后允许后悔，即相当于每次卖出之后可以立即以当天的股票价格再买入股票（无需手续费）” ，可以这样理解 ，假如手续费是fee，买入时股价为a，则买入价格是a+fee，假设未来股价b&gt;a+fee,c&gt;b，则显然a+fee的价格买入，c的价格时卖出利润最多，观察如下表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c - (a+fee) = (c - b) + (b - (a+fee))</span><br></pre></td></tr></table></figure>
<p>等式右边第一项即表示用b的价格（不含手续费）再次买入的收益。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//122. 不含手续费</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        int buy = prices[0];        // 假设第一天买入</span><br><span class="line">        for (int i = 1; i &lt; prices.length; i++) &#123;</span><br><span class="line">            if (prices[i] &lt; buy) &#123;  // 当前的价格更低，如果换成今天买入，未来的收益更高（后悔，重新买入）</span><br><span class="line">                buy = prices[i];</span><br><span class="line">            &#125; else if (prices[i] &gt; buy) &#123;   // 当前的价格卖出有利润，立刻卖出，未来可以后悔</span><br><span class="line">                ans += prices[i] - buy;</span><br><span class="line">                buy = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 上述程序可以简化</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 1; i &lt; prices.length; i++) &#123;</span><br><span class="line">            ans += Math.max(0, prices[i] - prices[i - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//714. 考虑手续费</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices, int fee) &#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        int buy = prices[0] + fee;        // 假设第一天买入</span><br><span class="line">        for (int i = 1; i &lt; prices.length; i++) &#123;</span><br><span class="line">            if (prices[i] + fee &lt; buy) &#123;  // 当前的价格更低，如果换成今天买入，未来的收益更高（后悔，重新买入）</span><br><span class="line">                buy = prices[i];</span><br><span class="line">            &#125; else if (prices[i] &gt; buy) &#123;   // 当前的价格卖出有利润，立刻卖出，未来可以后悔</span><br><span class="line">                ans += prices[i] - buy;</span><br><span class="line">                buy = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="2. 动态规划"></a>2. 动态规划</h4><p>也可以使用动态规划的方法求解，即一共做n次决策，每次决策是买入还是卖出或者是等待（不买入或不卖出），每次决策的结果对应一种状态。每种状态分别包含手中有股票和没有股票时的最大利润。初始状态，只能考虑买入股票（手中有股票）或者不买入（手中没有股票），对应的利润值分别是<code>-price[0]</code>和<code>0</code>；以后的每一天状态如下 ：</p>
<ul>
<li>手中有股票 ：前一天手中没有股票并在今天买入（如果有手续费则支付手续费）；前一天手中有股票并且今天没有卖出。</li>
<li>手中没有股票：前一天手中有股票并在今天卖出；前一天手中没有股票并且今天没有买入。<br>如果用一个<code>n*2</code>的数组<code>dp</code>表示状态表，<code>dp[i][0]</code>表示手中没有股票时的利润，<code>dp[i][1]</code>表示手中有股票时的利润，则状态转移过程如下 ：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][0]=max\&#123;dp[i−1][0],dp[i−1][1]+prices[i]−fee \&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][1]=max\&#123;dp[i−1][1],dp[i−1][0]−prices[i] \&#125;</span><br></pre></td></tr></table></figure>
当然也可以在股票买入的时候支付手续费，对应初始状态和状态转移方程如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[0][0] = 0;</span><br><span class="line">dp[0][1] = -prices[0] - fee;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][0]=max\&#123;dp[i−1][0],dp[i−1][1]+prices[i] \&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][1]=max\&#123;dp[i−1][1],dp[i−1][0]−prices[i]−fee \&#125;</span><br></pre></td></tr></table></figure>
为了节省空间，考虑到每天的状态只与前一天的状态有关，所以只动态地维护前一天的状态即可。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 未考虑手续费的程序</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int n = prices.length;</span><br><span class="line">        int dp0 = 0, dp1 = -prices[0];</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            int newDp0 = Math.max(dp0, dp1 + prices[i]);</span><br><span class="line">            int newDp1 = Math.max(dp1, dp0 - prices[i]);</span><br><span class="line">            dp0 = newDp0;</span><br><span class="line">            dp1 = newDp1;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="309-最佳买股票时机含冷冻期"><a href="#309-最佳买股票时机含冷冻期" class="headerlink" title="309. 最佳买股票时机含冷冻期"></a>309. 最佳买股票时机含冷冻期</h2>这里依然采用动态规划的方法求解，与前一题不同的是，第<code>i</code>的利润情况分为三种状态：<br>dp[i][0]: 手上持有股票的最大利润；</li>
<li>手中的股票是前一天剩下的且今天没有买入；</li>
<li>手中的股票是今天买入的，此时的前提是昨天没有卖出（不可从dp[i-1][1]转来）；<br>dp[i][1]: 手上不持有股票，今天卖出了股票（i+1天是冷冻期）的最大利润；</li>
<li>需要前一天手中有股票，即从dp[i-1][0]状态转来<br>dp[i][2]: 手上不持有股票，之前某天卖出股票（i+1天非冷冻期）的最大利润；</li>
<li>前一天手中没有股票且今天也没有买入。<br>状态转移方程如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f[i][0]=max(f[i−1][0],f[i−1][2]−prices[i])</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f[i][1]=f[i−1][0]+prices[i]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f[i][2]=max(f[i−1][1],f[i−1][2])</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        if (prices.length == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = prices.length;</span><br><span class="line">        int[][] dp = new int[n][3];</span><br><span class="line">        f[0][0] = -prices[0];</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][2] - prices[i]);</span><br><span class="line">            dp[i][1] = dp[i - 1][0] + prices[i];</span><br><span class="line">            dp[i][2] = Math.max(dp[i - 1][1], dp[i - 1][2]);</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(dp[n - 1][1], dp[n - 1][2]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>力扣刷题笔记</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
